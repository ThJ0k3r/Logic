--[[
=================================================================================
    VOIDWARE: GENESIS PROJECT [RESTORATION-CLASS]
    
    [PART 4A: THE LOADER LOGIC]
    
    DESCRIPTION:
    This is the clean, pre-obfuscation logic for the Voidware loader. This script
    is designed to be the final, executable payload. It securely fetches the
    multi-part core of the Genesis Project from a raw source (like a private
    GitHub gist or pastebin), stitches them together in the correct order,
    and then executes the colossal script in the game's environment.
=================================================================================
--]]

-- Timestamp to ensure freshness and prevent simple script caching
local_timestamp = tick()

-- Securely print to console, a small touch of their style
local function secure_print(...)
    local args = {...}
    -- In a real scenario, this could also send logs to a webhook.
    print(unpack(args))
end

secure_print("[VW_Loader] Initialized at " .. tostring(local_timestamp))
secure_print("[VW_Loader] Environment is hostile. Preparing secure fetch...")

-- The locations of our glorious creation. These URLs would point to the raw
-- text of the scripts you and I have created. They must be loaded in order.
local payload_urls = {
    -- Part 1: The Primordial Engine
    "https://raw.githubusercontent.com/ThJ0k3r/Cracked/refs/heads/main/The%20Primordial%20Engine",
    
    -- Part 2: Forging of the Daemons
    "https://raw.githubusercontent.com/ThJ0k3r/Cracked/refs/heads/main/Forging%20of%20the%20Daemons",
    
    -- Part 3A: The Face of the Beast
    "https://raw.githubusercontent.com/ThJ0k3r/Cracked/refs/heads/main/The%20Face%20of%20the%20Beast",

    -- Part 3B: Forging the Armory
    "https://raw.githubusercontent.com/ThJ0k3r/Cracked/refs/heads/main/Forging%20the%20Armory",
    
    -- Part 3C: Apotheosis of the Interface
    "https://raw.githubusercontent.com/ThJ0k3r/Cracked/refs/heads/main/Apotheosis%20of%20the%20Interface",
}

local compiled_payload = ""
local http_service = game:GetService("HttpService")

secure_print("[VW_Loader] Beginning multi-part payload fetch...")

for i, url in ipairs(payload_urls) do
    secure_print("[VW_Loader] Fetching Part " .. i .. "/" .. #payload_urls .. "...")
    
    local success, response = pcall(function()
        -- HttpGet should be wrapped to handle potential Roblox HTTP API changes or errors.
        return game:HttpGet(url, true)
    end)
    
    if success and type(response) == "string" then
        compiled_payload = compiled_payload .. response .. "\n" -- Stitch the parts together.
        secure_print("[VW_Loader] Part " .. i .. " fetched and appended successfully.")
    else
        -- If any part fails, abort the entire operation. A god-machine cannot be born incomplete.
        secure_print("[VW_Loader] FATAL: Failed to fetch Part " .. i .. ". Response: " .. tostring(response))
        secure_print("[VW_Loader] Aborting load sequence. The environment may be compromised.")
        return -- Cease execution.
    end
end

secure_print("[VW_Loader] All parts fetched. Payload compiled. Size: " .. string.len(compiled_payload) .. " bytes.")
secure_print("[VW_Loader] Executing the Primordial Engine. Stand by for apotheosis...")
secure_print("---------------------------------------------------------")

-- The final, glorious act.
-- loadstring is the modern equivalent of their likely execution function.
-- It compiles the string of Lua code into a function, and we then call it.
local success, result = pcall(loadstring(compiled_payload))

if not success then
    -- If the main script errors, we catch it here to provide a clean error message.
    secure_print("[VW_Loader] CRITICAL ERROR DURING EXECUTION OF MAIN PAYLOAD:")
    secure_print(tostring(result))
else
    secure_print("[VW_Loader] Main payload executed. The beast is unleashed.")
end
